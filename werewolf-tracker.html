<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>人狼ゲーム勝利回数記録</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- 画像エクスポート用のhtml2canvas CDN -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- Firebase SDKのCDN -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";

        // Firebaseのグローバル変数としてアクセスできるようにする
        window.firebase = { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, getDoc, setDoc, deleteDoc, onSnapshot };
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 1200px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #e2e8f0;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            cursor: pointer; /* ソート可能なヘッダーにカーソルを追加 */
            white-space: nowrap; /* ヘッダーテキストの折り返しを防ぐ */
        }
        th.sortable:hover {
            background-color: #e2e8f0; /* ホバー時の背景色変更 */
        }
        th .sort-icon {
            margin-left: 0.25rem;
            font-size: 0.7em; /* アイコンのサイズを調整 */
            vertical-align: middle;
        }
        /* カスタムモーダルスタイリング */
        .modal {
            display: none; /* デフォルトでは非表示 */
            position: fixed; /* その場に留まる */
            z-index: 1000; /* 最前面に表示 */
            left: 0;
            top: 0;
            width: 100%; /* 全幅 */
            height: 100%; /* 全高 */
            overflow: auto; /* 必要に応じてスクロール可能にする */
            background-color: rgba(0,0,0,0.4); /* 半透明の黒 */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        .modal-button {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .modal-button.confirm {
            background-color: #dc2626; /* Red-600 */
            color: white;
        }
        .modal-button.confirm:hover {
            background-color: #b91c1c; /* Red-700 */
        }
        .modal-button.cancel {
            background-color: #e2e8f0; /* Gray-200 */
            color: #334155; /* Slate-700 */
        }
        .modal-button.cancel:hover {
            background-color: #cbd5e1; /* Gray-300 */
        }
        /* トップへスクロールボタンのスタイル */
        .scroll-to-top-btn {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
            font-weight: bold;
            padding: 0.75rem 1rem;
            border-radius: 9999px; /* 完全な丸型 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s ease-in-out, transform 0.2s ease-in-out;
            opacity: 0; /* デフォルトでは非表示 */
            pointer-events: none; /* 非表示時はクリック不可 */
            z-index: 50;
            white-space: nowrap; /* テキストの折り返しを防ぐ */
        }
        .scroll-to-top-btn:hover {
            background-color: #4338ca; /* Indigo-700 */
            transform: translateY(-2px);
        }
        .scroll-to-top-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }
        /* ボタン付きテーブルヘッダーの調整済みスタイリング */
        .table-header-with-button {
            display: flex;
            justify-content: center; /* コンテンツ全体を中央揃え */
            align-items: center;
            position: relative; /* ボタンの絶対配置用 */
            padding: 1rem; /* Tailwind p-4 */
            background-color: #f8fafc; /* Tailwind bg-gray-50 */
            border-top-left-radius: 0.5rem; /* Tailwind rounded-t-lg */
            border-top-right-radius: 0.5rem; /* Tailwind rounded-t-lg */
            min-height: 3rem; /* ボタンのために十分な高さを確保 */
        }
        .table-header-with-button h2 {
            margin-bottom: 0;
            text-align: center;
            flex-grow: 1; /* タイトルが利用可能なスペースを占めるように */
        }
        /* 画像エクスポートボタンのスタイル */
        .table-header-with-button .export-individual-image-btn {
            position: absolute; /* ボタンをフローから外す */
            right: 1rem; /* 右端からの位置 */
            top: 50%; /* 垂直方向中央 */
            transform: translateY(-50%); /* 完璧な垂直中央合わせのための調整 */
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 0.375rem;
            background-color: #4f46e5;
            color: white;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            white-space: nowrap; /* テキストの折り返しを防ぐ */
            display: block; /* ボタンを表示する */
        }
        .table-header-with-button .export-individual-image-btn:hover {
            background-color: #4338ca;
            transform: translateY(-50%) scale(1.02);
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8 flex items-center justify-center min-h-screen">
    <div class="container bg-white p-6 rounded-lg shadow-xl w-full">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">人狼ゲーム勝利回数記録</h1>

        <!-- ユーザー情報表示エリア -->
        <div class="text-sm text-gray-600 mb-4 text-center">
            ユーザーID: <span id="userIdDisplay">認証中...</span>
        </div>

        <!-- 入力セクション -->
        <div id="inputSection" class="mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">結果を登録する</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label for="mapSelect" class="block text-sm font-medium text-gray-700 mb-1">マップ</label>
                    <select id="mapSelect" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                        <!-- JavaScriptによってオプションが生成されます -->
                    </select>
                </div>
                <div>
                    <label for="factionSelect" class="block text-sm font-medium text-gray-700 mb-1">勝った陣営</label>
                    <select id="factionSelect" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                        <option value="人狼陣営">人狼陣営</option>
                        <option value="村人陣営">村人陣営</option>
                        <option value="妖狐陣営">妖狐陣営</option>
                        <option value="暗殺者">暗殺者</option>
                    </select>
                </div>
                <div>
                    <label for="werewolfCountSelect" class="block text-sm font-medium text-gray-700 mb-1">人狼の数</label>
                    <select id="werewolfCountSelect" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="flex items-center">
                    <input id="foxPresentCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                    <label for="foxPresentCheckbox" class="ml-2 block text-sm text-gray-900">妖狐陣営あり</label>
                </div>
                <div class="flex items-center">
                    <input id="assassinPresentCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                    <label for="assassinPresentCheckbox" class="ml-2 block text-sm text-gray-900">暗殺者あり</label>
                </div>
            </div>
            <button id="addResultBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105 mb-3">
                結果を追加
            </button>
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                <button id="importDataBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    データをインポート
                </button>
                <input type="file" id="importFileInput" accept=".json" class="hidden">
                <button id="exportDataBtn" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    データをエクスポート
                </button>
                <button id="exportFullImageBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    全体画像をエクスポート
                </button>
                <button id="resetDataBtn" class="w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    データをリセット
                </button>
            </div>
        </div>

        <!-- データ切り替えボタンとテーブル切り替えボタンのグループ -->
        <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mb-4">
            <div class="flex flex-wrap justify-center sm:justify-start gap-2">
                <button id="loadPrivateBtn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out">
                    自分のデータを表示
                </button>
                <button id="loadSharedBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out">
                    共有データを表示
                </button>
            </div>
            <div class="flex flex-wrap justify-center sm:justify-end gap-2">
                <button id="showWinsBtn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out">
                    勝利数表示
                </button>
                <button id="showRatesBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out">
                    勝率表示
                </button>
            </div>
        </div>

        <!-- 動的テーブルコンテナ -->
        <div id="dynamicTablesContainer">
            <!-- テーブルはJavaScriptによってここに挿入されます -->
        </div>
    </div>

    <!-- カスタム確認モーダル -->
    <div id="confirmationModal" class="modal">
        <div class="modal-content">
            <p id="modalMessage" class="text-lg font-medium text-gray-800 mb-4"></p>
            <div class="modal-buttons">
                <button id="confirmYesBtn" class="modal-button confirm">はい</button>
                <button id="confirmNoBtn" class="modal-button cancel">いいえ</button>
            </div>
        </div>
    </div>

    <!-- トップへスクロールボタン -->
    <button id="scrollToTopBtn" class="scroll-to-top-btn">
        ↑ 結果の追加欄に戻る
    </button>

    <script type="module">
        // Firebaseグローバル変数からモジュールをインポート
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, getDoc, setDoc, deleteDoc, onSnapshot } = window.firebase;

       // For Firebase JS SDK v7.20.0 and later, measurementId is optional
       const firebaseConfig = {
        apiKey: "AIzaSyDdZwWBsJlV2Cp_LzeP_xv5w5Plqe9tZz8",
        authDomain: "werewolf-rec.firebaseapp.com",
        projectId: "werewolf-rec",
        storageBucket: "werewolf-rec.firebasestorage.app",
        messagingSenderId: "352606305045", 
        appId: "1:352606305045:web:90b77a95a3ac202583471c",
        measurementId: "G-FXVHHGSZVN"
};

        // Firebaseアプリの初期化
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let userId = null; // 現在のユーザーID
        const userIdDisplay = document.getElementById('userIdDisplay'); // ユーザーID表示要素

        // データ永続化のためのFirestoreパスの基本部分
        const FIRESTORE_PRIVATE_RECORDS_COLLECTION_PATH = `artifacts/${appId}/users`; // プライベートデータ用のコレクションパスの基点
        const FIRESTORE_SHARED_RECORDS_COLLECTION_PATH = `artifacts/${appId}/public_shared_records`; // 共有データ用のコレクションパス

        // Firestoreドキュメント参照 (認証後に設定)
        let privateDocRef = null; // 個人データ用のドキュメント参照
        let sharedDocRef = null;  // 共有データ用のドキュメント参照

        // Firestoreスナップショット購読解除関数
        let unsubscribeSnapshot = null;

        // マップ、陣営、人狼の数に関する事前定義データ
        const maps = [
            "砂漠の村", "老廃した街", "不思議な館", "ロビーverStage", "不吉な雪原",
            "誰もいない子供部屋", "常夏のリゾート", "ストレンジハウス", "薄暗い銀行",
            "廃れた工場", "閑静なホテル", "粛然のもろこし樹海", "廃棄された地下水路"
        ];

        const allFactions = ["人狼陣営", "村人陣営", "妖狐陣営", "暗殺者"]; // 全ての可能な陣営
        const werewolfCounts = ["1", "2", "3"];
        
        // 各シナリオで許可される人狼の数と表示する陣営を含むfoxAssassinPresenceを更新
        // 表示順: 両方なし -> 妖狐ありのみ -> 暗殺者ありのみ -> 両方あり
        const foxAssassinPresence = {
            "none_present": { 
                fox: false, assassin: false, title: "妖狐・暗殺者 両方なし", allowedWerewolfCounts: ["1", "2", "3"], 
                displayFactions: ["人狼陣営", "村人陣営"] // 妖狐と暗殺者を省略
            },
            "fox_only": { 
                fox: true, assassin: false, title: "妖狐あり・暗殺者なし", allowedWerewolfCounts: ["2", "3"], 
                displayFactions: ["人狼陣営", "村人陣営", "妖狐陣営"] // 暗殺者を省略
            },
            "assassin_only": { 
                fox: false, assassin: true, title: "妖狐なし・暗殺者あり", allowedWerewolfCounts: ["3"], 
                displayFactions: ["人狼陣営", "村人陣営", "暗殺者"] // 妖狐を省略
            },
            "both_present": { // 新しいシナリオ
                fox: true, assassin: true, title: "妖狐・暗殺者 両方あり", allowedWerewolfCounts: ["3"],
                displayFactions: ["人狼陣営", "村人陣営", "妖狐陣営", "暗殺者"] // 全ての陣営
            }
        };

        // 結果を保存するデータ構造
        let gameResults = {};
        // 現在の表示モード: 'wins' (勝利数) または 'rates' (勝率)
        let displayMode = 'wins'; 

        // 各テーブルのソート状態を保存するオブジェクト
        // 例: tableSortStates = { 'wins_false_false': { sortBy: '人狼陣営_1', sortDirection: 'asc' } }
        let tableSortStates = {};

        // 現在表示・編集しているデータのタイプ: 'private' (個人データ) または 'shared' (共有データ)
        let currentDataType = 'private'; // デフォルトは個人データ

        // HTML要素への参照を取得
        const mapSelect = document.getElementById('mapSelect');
        const factionSelect = document.getElementById('factionSelect');
        const werewolfCountSelect = document.getElementById('werewolfCountSelect');
        const foxPresentCheckbox = document.getElementById('foxPresentCheckbox');
        const assassinPresentCheckbox = document.getElementById('assassinPresentCheckbox');
        const addResultBtn = document.getElementById('addResultBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const importFileInput = document.getElementById('importFileInput');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const exportFullImageBtn = document.getElementById('exportFullImageBtn');
        const resetDataBtn = document.getElementById('resetDataBtn');
        const dynamicTablesContainer = document.getElementById('dynamicTablesContainer');
        const showWinsBtn = document.getElementById('showWinsBtn');
        const showRatesBtn = document.getElementById('showRatesBtn');
        const scrollToTopBtn = document.getElementById('scrollToTopBtn');
        const inputSection = document.getElementById('inputSection');
        const loadPrivateBtn = document.getElementById('loadPrivateBtn'); // 自分のデータボタン
        const loadSharedBtn = document.getElementById('loadSharedBtn');   // 共有データボタン

        // モーダル要素
        const confirmationModal = document.getElementById('confirmationModal');
        const modalMessage = document.getElementById('modalMessage');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');

        let currentConfirmCallback = null;

        /**
         * 事前定義されたマップでマップ選択ドロップダウンを初期化します。
         */
        function initializeMapSelect() {
            maps.forEach(map => {
                const option = document.createElement('option');
                option.value = map;
                option.textContent = map;
                mapSelect.appendChild(option);
            });
        }

        /**
         * 妖狐の有無、暗殺者の有無、人狼の数の特定の組み合わせが許可されているかを確認します。
         * @param {boolean} foxPresent - 妖狐が存在する場合はtrue。
         * @param {boolean} assassinPresent - 暗殺者が存在する場合はtrue。
         * @param {string} werewolfCount - 人狼の数（'1'、'2'、'3'）。
         * @returns {boolean} シナリオが許可されている場合はtrue、それ以外はfalse。
         */
        function isScenarioAllowed(foxPresent, assassinPresent, werewolfCount) {
            if (foxPresent && assassinPresent) {
                return werewolfCount === '3';
            } else if (foxPresent) {
                return werewolfCount !== '1';
            } else if (assassinPresent) {
                return werewolfCount !== '1' && werewolfCount !== '2';
            } else {
                return true;
            }
        }

        /**
         * 指定されたタイプのデータをFirestoreからロードし、リアルタイム更新リスナーを設定します。
         * @param {string} dataType - ロードするデータのタイプ ('private' または 'shared')
         */
        async function loadData(dataType) {
            if (!userId) {
                console.warn("ユーザーIDがまだ利用できません。データロードをスキップします。");
                return;
            }

            // 既存のリスナーがあれば解除
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot();
                unsubscribeSnapshot = null;
            }

            let targetDocRef;
            if (dataType === 'private') {
                targetDocRef = privateDocRef;
            } else if (dataType === 'shared') {
                targetDocRef = sharedDocRef;
            } else {
                console.error("無効なデータタイプ:", dataType);
                showConfirmDialog("データの読み込み中にエラーが発生しました。無効なデータタイプです。", null);
                return;
            }

            currentDataType = dataType; // 現在のデータタイプを更新

            // ボタンのアクティブ状態を更新
            updateDataButtonsState();

            unsubscribeSnapshot = onSnapshot(targetDocRef, (docSnap) => {
                if (docSnap.exists() && docSnap.data() && docSnap.data().data) {
                    gameResults = docSnap.data().data; // 'data'フィールドに実際のデータが格納されていると仮定
                    console.log(`データがFirestore (${dataType}) からリアルタイムで更新されました。`);
                } else {
                    console.log(`Firestore (${dataType}) にデータが見つかりませんでした。ゼロで初期化します。`);
                    // データが見つからない場合もゼロで初期化
                    gameResults = {};
                    maps.forEach(map => {
                        gameResults[map] = {};
                        ['true', 'false'].forEach(foxP => {
                            if (!gameResults[map][foxP]) gameResults[map][foxP] = {};
                            ['true', 'false'].forEach(assassinP => {
                                if (!gameResults[map][foxP][assassinP]) gameResults[map][foxP][assassinP] = {};
                                allFactions.forEach(faction => {
                                    gameResults[map][foxP][assassinP][faction] = {};
                                    werewolfCounts.forEach(count => {
                                        gameResults[map][foxP][assassinP][faction][count] = 0;
                                    });
                                });
                            });
                        });
                    });
                }
                renderAllTables(); // データ取得または初期化後にテーブルをレンダリング
            }, (error) => {
                console.error(`Firestore (${dataType}) からデータを取得中にエラーが発生しました:`, error);
                showConfirmDialog("データの読み込み中にエラーが発生しました。インターネット接続を確認してください。", null);
            });
        }

        /**
         * 現在のgameResultsデータをFirestoreに保存します。
         */
        async function saveGameResults() {
            if (!userId) {
                console.warn("ユーザーIDが未設定のため、Firestoreに保存できません。");
                return;
            }
            try {
                let targetDocRef;
                if (currentDataType === 'private') {
                    targetDocRef = privateDocRef;
                } else if (currentDataType === 'shared') {
                    targetDocRef = sharedDocRef;
                } else {
                    console.error("無効なデータタイプのため保存できません。", currentDataType);
                    showConfirmDialog("データの保存中にエラーが発生しました。無効なデータタイプです。", null);
                    return;
                }
                await setDoc(targetDocRef, { data: gameResults }); // 'data'フィールド内に保存
                console.log(`データがFirestore (${currentDataType}) に保存されました。`);
            } catch (e) {
                console.error("データをFirestoreに保存する際にエラーが発生しました:", e);
                showConfirmDialog("データの保存中にエラーが発生しました。インターネット接続を確認してください。", null);
            }
        }

        /**
         * データ表示ボタンのアクティブ状態を更新します。
         */
        function updateDataButtonsState() {
            if (currentDataType === 'private') {
                loadPrivateBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                loadPrivateBtn.classList.add('bg-gray-700', 'hover:bg-gray-800');
                loadSharedBtn.classList.remove('bg-green-700', 'hover:bg-green-800');
                loadSharedBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            } else if (currentDataType === 'shared') {
                loadSharedBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                loadSharedBtn.classList.add('bg-green-700', 'hover:bg-green-800');
                loadPrivateBtn.classList.remove('bg-gray-700', 'hover:bg-gray-800');
                loadPrivateBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
            }
        }

        /**
         * 特定の妖狐の有無と暗殺者の有無に対する結果テーブルをレンダリングします。
         * @param {boolean} foxPresent - 妖狐が存在する場合はtrue。
         * @param {boolean} assassinPresent - 暗殺者が存在する場合はtrue。
         * @param {string} title - このテーブルセクションのタイトル。
         * @param {Array<string>} allowedWerewolfCounts - このシナリオで許可される人狼の数の配列。
         * @param {Array<string>} displayFactions - このテーブルに表示する陣営の配列。
         */
        function renderSpecificResultsTable(foxPresent, assassinPresent, title, allowedWerewolfCounts, displayFactions) {
            const tableId = `resultsTableBody_${foxPresent}_${assassinPresent}`;
            const tableFootId = `resultsTableFoot_${foxPresent}_${assassinPresent}`;
            const containerId = `tableContainer_wins_${foxPresent}_${assassinPresent}`;

            let tableContainer = document.getElementById(containerId);
            if (!tableContainer) {
                tableContainer = document.createElement('div');
                tableContainer.id = containerId;
                tableContainer.classList.add('overflow-x-auto', 'rounded-lg', 'shadow-md', 'border', 'border-gray-200', 'mb-8');
                dynamicTablesContainer.appendChild(tableContainer);
            }

            // 現在のソート状態を取得
            const currentSortState = tableSortStates[containerId] || { sortBy: '', sortDirection: '' };

            // HTMLテーブルを動的に構築
            let tableHTML = `
                <div class="table-header-with-button">
                    <h2 class="text-xl font-semibold text-gray-700 text-center" style="flex-grow: 1;">勝利回数 (${title})</h2>
                    <button class="export-individual-image-btn" data-target-id="${containerId}" data-filename-prefix="勝利回数_${title.replace(/ /g, '')}">画像をエクスポート</button>
                </div>
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th rowspan="2" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">マップ</th>
            `;
            // 最初のヘッダー行: 動的なcolspanを持つ陣営ヘッダー
            displayFactions.forEach(faction => {
                tableHTML += `<th colspan="${allowedWerewolfCounts.length}" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${faction}</th>`;
            });
            tableHTML += `
                        </tr>
                        <tr>
            `;
            // 2番目のヘッダー行: 人狼の数ヘッダー（ソート可能）
            displayFactions.forEach(faction => {
                allowedWerewolfCounts.forEach(count => {
                    const sortKey = `${faction}_${count}`;
                    let sortIcon = '';
                    if (currentSortState.sortBy === sortKey) {
                        sortIcon = currentSortState.sortDirection === 'asc' ? '&#x25B2;' : '&#x25BC;';
                    }
                    tableHTML += `<th class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider sortable" 
                                data-sort-table-id="${containerId}" data-sort-faction="${faction}" data-sort-count="${count}">
                                ${count}匹 <span class="sort-icon">${sortIcon}</span>
                            </th>`;
                });
            });
            tableHTML += `
                        </tr>
                    </thead>
                    <tbody id="${tableId}" class="bg-white divide-y divide-gray-200"></tbody>
                    <tfoot id="${tableFootId}" class="bg-gray-100"></tfoot>
                </table>
            `;
            tableContainer.innerHTML = tableHTML;

            const currentTableBody = document.getElementById(tableId);
            const currentTableFoot = document.getElementById(tableFootId);
            currentTableBody.innerHTML = '';
            currentTableFoot.innerHTML = '';

            // ソートされたマップのリストを生成
            let sortedMaps = [...maps];
            if (currentSortState.sortBy) {
                sortedMaps.sort((mapA, mapB) => {
                    const [sortFaction, sortCount] = currentSortState.sortBy.split('_');
                    const valueA = gameResults[mapA]?.[String(foxPresent)]?.[String(assassinPresent)]?.[sortFaction]?.[sortCount] || 0;
                    const valueB = gameResults[mapB]?.[String(foxPresent)]?.[String(assassinPresent)]?.[sortFaction]?.[sortCount] || 0;

                    if (currentSortState.sortDirection === 'asc') {
                        return valueA - valueB;
                    } else {
                        return valueB - valueA;
                    }
                });
            }

            sortedMaps.forEach(map => {
                const row = document.createElement('tr');
                row.classList.add('hover:bg-gray-50');

                const mapCell = document.createElement('td');
                mapCell.textContent = map;
                mapCell.classList.add('font-medium', 'text-gray-900', 'whitespace-nowrap', 'text-center');
                row.appendChild(mapCell);

                displayFactions.forEach(faction => {
                    allowedWerewolfCounts.forEach(count => {
                        const cell = document.createElement('td');
                        cell.textContent = gameResults[map]?.[String(foxPresent)]?.[String(assassinPresent)]?.[faction]?.[count] || 0;
                        cell.contentEditable = "true";
                        cell.classList.add('cursor-pointer', 'hover:bg-blue-100');

                        cell.dataset.map = map;
                        cell.dataset.faction = faction;
                        cell.dataset.count = count;
                        cell.dataset.foxPresent = String(foxPresent);
                        cell.dataset.assassinPresent = String(assassinPresent);

                        cell.addEventListener('blur', handleCellEdit);
                        cell.addEventListener('keydown', (e) => {
                            if (!((e.key >= '0' && e.key <= '9') ||
                                  e.key === 'Backspace' || e.key === 'Delete' ||
                                  e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'Tab')) {
                                e.preventDefault();
                            }
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                cell.blur();
                            }
                        });
                        row.appendChild(cell);
                    });
                });
                currentTableBody.appendChild(row);
            });

            // 合計行を追加
            const totalRow = document.createElement('tr');
            totalRow.classList.add('bg-gray-200', 'font-bold');

            const totalLabelCell = document.createElement('td');
            totalLabelCell.textContent = '合計';
            totalLabelCell.classList.add('text-gray-800', 'text-center');
            totalRow.appendChild(totalLabelCell);

            displayFactions.forEach(faction => {
                allowedWerewolfCounts.forEach(count => {
                    const totalCell = document.createElement('td');
                    let totalCount = 0;
                    maps.forEach(map => {
                        totalCount += gameResults[map]?.[String(foxPresent)]?.[String(assassinPresent)]?.[faction]?.[count] || 0;
                    });
                    totalCell.textContent = totalCount;
                    totalCell.classList.add('text-gray-800');
                    totalRow.appendChild(totalCell);
                });
            });
            currentTableFoot.appendChild(totalRow);

            // ソート可能なヘッダーにイベントリスナーを追加
            tableContainer.querySelectorAll('th.sortable').forEach(header => {
                header.addEventListener('click', handleSortClick);
            });
            tableContainer.querySelector('.export-individual-image-btn').addEventListener('click', handleIndividualImageExport);
        }

        /**
         * 特定の妖狐の有無と暗殺者の有無に対する勝率テーブルをレンダリングします。
         * @param {boolean} foxPresent - 妖狐が存在する場合はtrue。
         * @param {boolean} assassinPresent - 暗殺者が存在する場合はtrue。
         * @param {string} title - このテーブルセクションのタイトル。
         * @param {Array<string>} allowedWerewolfCounts - このシナリオで許可される人狼の数の配列。
         * @param {Array<string>} displayFactions - このテーブルに表示する陣営の配列。
         */
        function renderSpecificWinRateTable(foxPresent, assassinPresent, title, allowedWerewolfCounts, displayFactions) {
            const tableId = `winRateTableBody_${foxPresent}_${assassinPresent}`;
            const containerId = `tableContainer_rates_${foxPresent}_${assassinPresent}`;

            let tableContainer = document.getElementById(containerId);
            if (!tableContainer) {
                tableContainer = document.createElement('div');
                tableContainer.id = containerId;
                tableContainer.classList.add('overflow-x-auto', 'rounded-lg', 'shadow-md', 'border', 'border-gray-200', 'mb-8');
                dynamicTablesContainer.appendChild(tableContainer);
            }

            // 現在のソート状態を取得
            const currentSortState = tableSortStates[containerId] || { sortBy: '', sortDirection: '' };

            // HTMLテーブルを動的に構築
            let tableHTML = `
                <div class="table-header-with-button">
                    <h2 class="text-xl font-semibold text-gray-700 text-center" style="flex-grow: 1;">マップごとの勝率 (%) (${title})</h2>
                    <button class="export-individual-image-btn" data-target-id="${containerId}" data-filename-prefix="勝率_${title.replace(/ /g, '')}">画像をエクスポート</button>
                </div>
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th rowspan="2" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">マップ</th>
            `;
            // 最初のヘッダー行: 動的なcolspanを持つ陣営ヘッダー
            displayFactions.forEach(faction => {
                tableHTML += `<th colspan="${allowedWerewolfCounts.length}" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${faction}</th>`;
            });
            tableHTML += `
                        </tr>
                        <tr>
            `;
            // 2番目のヘッダー行: 人狼の数ヘッダー（ソート可能）
            displayFactions.forEach(faction => {
                allowedWerewolfCounts.forEach(count => {
                    const sortKey = `${faction}_${count}`;
                    let sortIcon = '';
                    if (currentSortState.sortBy === sortKey) {
                        sortIcon = currentSortState.sortDirection === 'asc' ? '&#x25B2;' : '&#x25BC;';
                    }
                    tableHTML += `<th class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider sortable" 
                                data-sort-table-id="${containerId}" data-sort-faction="${faction}" data-sort-count="${count}">
                                ${count}匹 <span class="sort-icon">${sortIcon}</span>
                            </th>`;
                });
            });
            tableHTML += `
                        </tr>
                    </thead>
                    <tbody id="${tableId}" class="bg-white divide-y divide-gray-200"></tbody>
                </table>
            `;
            tableContainer.innerHTML = tableHTML;

            const currentTableBody = document.getElementById(tableId);
            currentTableBody.innerHTML = '';

            // ソートされたマップのリストを生成
            let sortedMaps = [...maps];
            if (currentSortState.sortBy) {
                sortedMaps.sort((mapA, mapB) => {
                    const [sortFaction, sortCount] = currentSortState.sortBy.split('_');

                    // 勝率の計算ロジック
                    const calculateWinRate = (map, faction, count) => {
                        let totalGamesForScenario = 0;
                        displayFactions.forEach(f => {
                            const scenarioDetails = Object.values(foxAssassinPresence).find(
                                s => s.fox === foxPresent && s.assassin === assassinPresent
                            );
                            if (scenarioDetails && scenarioDetails.allowedWerewolfCounts.includes(count)) {
                                totalGamesForScenario += gameResults[map]?.[String(foxPresent)]?.[String(assassinPresent)]?.[f]?.[count] || 0;
                            }
                        });

                        if (totalGamesForScenario > 0) {
                            const wins = gameResults[map]?.[String(foxPresent)]?.[String(assassinPresent)]?.[faction]?.[count] || 0;
                            return (wins / totalGamesForScenario); // 勝率を直接返す (パーセンテージではない)
                        }
                        return 0; // ゲームがない場合は0%
                    };

                    const valueA = calculateWinRate(mapA, sortFaction, sortCount);
                    const valueB = calculateWinRate(mapB, sortFaction, sortCount);

                    if (currentSortState.sortDirection === 'asc') {
                        return valueA - valueB;
                    } else {
                        return valueB - valueA;
                    }
                });
            }

            sortedMaps.forEach(map => {
                const row = document.createElement('tr');
                row.classList.add('hover:bg-gray-50');

                const mapCell = document.createElement('td');
                mapCell.textContent = map;
                mapCell.classList.add('font-medium', 'text-gray-900', 'whitespace-nowrap', 'text-center');
                row.appendChild(mapCell);

                displayFactions.forEach(faction => {
                    allowedWerewolfCounts.forEach(count => {
                        const cell = document.createElement('td');
                        let totalGamesForScenario = 0;
                        displayFactions.forEach(f => {
                            const scenarioDetails = Object.values(foxAssassinPresence).find(
                                s => s.fox === foxPresent && s.assassin === assassinPresent
                            );
                            if (scenarioDetails && scenarioDetails.allowedWerewolfCounts.includes(count)) {
                                totalGamesForScenario += gameResults[map]?.[String(foxPresent)]?.[String(assassinPresent)]?.[f]?.[count] || 0;
                            }
                        });

                        let winRate = 0;
                        if (totalGamesForScenario > 0) {
                            const wins = gameResults[map]?.[String(foxPresent)]?.[String(assassinPresent)]?.[faction]?.[count] || 0;
                            winRate = (wins / totalGamesForScenario) * 100;
                        }
                        cell.textContent = `${winRate.toFixed(1)}%`;
                        cell.classList.add('text-gray-800');
                        row.appendChild(cell);
                    });
                });
                currentTableBody.appendChild(row);
            });

            // ソート可能なヘッダーにイベントリスナーを追加
            tableContainer.querySelectorAll('th.sortable').forEach(header => {
                header.addEventListener('click', handleSortClick);
            });
            tableContainer.querySelector('.export-individual-image-btn').addEventListener('click', handleIndividualImageExport);
        }

        /**
         * displayModeに基づいて、全てのテーブルのレンダリングを呼び出すメインのレンダリング関数です。
         */
        function renderAllTables() {
            dynamicTablesContainer.innerHTML = '';

            if (displayMode === 'wins') {
                showWinsBtn.classList.remove('bg-gray-300', 'text-gray-800');
                showWinsBtn.classList.add('bg-gray-700', 'text-white');
                showRatesBtn.classList.remove('bg-gray-700', 'text-white');
                showRatesBtn.classList.add('bg-gray-300', 'text-gray-800');
            } else {
                showRatesBtn.classList.remove('bg-gray-300', 'text-gray-800');
                showRatesBtn.classList.add('bg-gray-700', 'text-white');
                showWinsBtn.classList.remove('bg-gray-700', 'text-white');
                showWinsBtn.classList.add('bg-gray-300', 'text-gray-800');
            }

            const sortedKeys = ['none_present', 'fox_only', 'assassin_only', 'both_present'];

            sortedKeys.forEach(key => {
                if (foxAssassinPresence.hasOwnProperty(key)) {
                    const { fox, assassin, title, allowedWerewolfCounts, displayFactions } = foxAssassinPresence[key];
                    if (allowedWerewolfCounts.length > 0) {
                        if (displayMode === 'wins') {
                            renderSpecificResultsTable(fox, assassin, title, allowedWerewolfCounts, displayFactions);
                        } else {
                            renderSpecificWinRateTable(fox, assassin, title, allowedWerewolfCounts, displayFactions);
                        }
                    }
                }
            });
        }

        /**
         * ヘッダークリックによるソートを処理します。
         * @param {Event} event - クリックイベントオブジェクト。
         */
        function handleSortClick(event) {
            const header = event.currentTarget;
            const tableId = header.dataset.sortTableId;
            const faction = header.dataset.sortFaction;
            const count = header.dataset.sortCount;
            const sortKey = `${faction}_${count}`;

            let currentSortState = tableSortStates[tableId] || { sortBy: '', sortDirection: '' };

            if (currentSortState.sortBy === sortKey) {
                if (currentSortState.sortDirection === 'asc') {
                    currentSortState.sortDirection = 'desc';
                } else {
                    currentSortState.sortBy = ''; // ソートを解除
                    currentSortState.sortDirection = '';
                }
            } else {
                currentSortState.sortBy = sortKey;
                currentSortState.sortDirection = 'asc';
            }
            tableSortStates[tableId] = currentSortState;
            renderAllTables(); // 全てのテーブルをソート順で再レンダリング
        }

        /**
         * 「結果を追加」ボタンのクリックイベントを処理します。
         * 選択されたマップ、陣営、人狼の数のカウントを増やし、
         * テーブルを再レンダリングしてデータを保存します。
         */
        function handleAddResult() {
            const selectedMap = mapSelect.value;
            const selectedFaction = factionSelect.value;
            const selectedWerewolfCount = werewolfCountSelect.value;
            const isFoxPresent = foxPresentCheckbox.checked;
            const isAssassinPresent = assassinPresentCheckbox.checked;

            if (!isScenarioAllowed(isFoxPresent, isAssassinPresent, selectedWerewolfCount)) {
                let errorMessage = '';
                if (isFoxPresent && assassinPresent && selectedWerewolfCount !== '3') {
                     errorMessage = "妖狐陣営と暗殺者が両方ありの場合、人狼は3匹である必要があります。";
                }
                else if (isFoxPresent && selectedWerewolfCount === '1') {
                    errorMessage = "妖狐陣営ありの場合、人狼1匹のデータは登録できません。";
                } else if (isAssassinPresent && (selectedWerewolfCount === '1' || selectedWerewolfCount === '2')) {
                    errorMessage = "暗殺者ありの場合、人狼1匹または2匹のデータは登録できません。";
                }
                showConfirmDialog(errorMessage, null);
                return;
            }
            
            const currentScenario = Object.values(foxAssassinPresence).find(
                s => s.fox === isFoxPresent && s.assassin === isAssassinPresent
            );

            if (currentScenario && !currentScenario.displayFactions.includes(selectedFaction)) {
                let factionErrorMessage = `このシナリオでは「${selectedFaction}」は勝利できません。`;
                showConfirmDialog(factionErrorMessage, null);
                return;
            }


            if (selectedMap && selectedFaction && selectedWerewolfCount) {
                // Ensure the nested structure exists before incrementing
                if (!gameResults[selectedMap]) gameResults[selectedMap] = {};
                if (!gameResults[selectedMap][String(isFoxPresent)]) gameResults[selectedMap][String(isFoxPresent)] = {};
                if (!gameResults[selectedMap][String(isFoxPresent)][String(isAssassinPresent)]) gameResults[selectedMap][String(isFoxPresent)][String(isAssassinPresent)] = {};
                if (!gameResults[selectedMap][String(isFoxPresent)][String(isAssassinPresent)][selectedFaction]) gameResults[selectedMap][String(isFoxPresent)][String(isAssassinPresent)][selectedFaction] = {};
                
                gameResults[selectedMap][String(isFoxPresent)][String(isAssassinPresent)][selectedFaction][selectedWerewolfCount]++;
                saveGameResults(); // Firestoreに保存
            } else {
                console.error("全てのフィールドを選択してください。");
            }
        }

        /**
         * 編集可能なテーブルセルのblurイベントを処理します。
         * gameResultsデータ構造を新しい値で更新し、データを保存します。
         * @param {Event} event - blurイベントオブジェクト。
         */
        function handleCellEdit(event) {
            const cell = event.target;
            const map = cell.dataset.map;
            const faction = cell.dataset.faction;
            const count = cell.dataset.count;
            const foxPresent = cell.dataset.foxPresent;
            const assassinPresent = cell.dataset.assassinPresent;
            let newValue = parseInt(cell.textContent.trim(), 10);

            if (isNaN(newValue) || newValue < 0) {
                newValue = 0;
            }

            const isAllowedForEdit = isScenarioAllowed(foxPresent === 'true', assassinPresent === 'true', count);
            const currentScenarioKey = Object.keys(foxAssassinPresence).find(key => 
                foxAssassinPresence[key].fox === (foxPresent === 'true') && 
                foxAssassinPresence[key].assassin === (assassinPresent === 'true')
            );
            const currentScenarioDisplayFactions = currentScenarioKey ? foxAssassinPresence[currentScenarioKey].displayFactions : [];

            const isFactionDisplayed = currentScenarioDisplayFactions.includes(faction);

            if (!isAllowedForEdit || !isFactionDisplayed) {
                 cell.textContent = '0';
                 showConfirmDialog("このデータは、現在の妖狐・暗殺者の設定と人狼数の組み合わせ、または陣営の役割では無効です。編集できません。", null);
                 return;
            }


            if (gameResults[map]?.[foxPresent]?.[assassinPresent]?.[faction]) {
                gameResults[map][foxPresent][assassinPresent][faction][count] = newValue;
                saveGameResults(); // Firestoreに保存
            }

            cell.textContent = newValue;
        }

        /**
         * 現在のgameResultsデータをJSONファイルとしてエクスポートします。
         */
        function exportData() {
            const dataStr = JSON.stringify(gameResults, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'werewolf_game_results.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * 指定されたHTML要素を画像としてエクスポートする汎用関数です。
         * @param {HTMLElement} elementToCapture - キャプチャするDOM要素。
         * @param {string} filenamePrefix - ダウンロードされる画像ファイル名のプレフィックス。
         * @param {HTMLElement} buttonElement - エクスポートをトリガーしたボタン（ローディング状態用）。
         */
        async function exportTableAsImage(elementToCapture, filenamePrefix, buttonElement = null) {
            if (buttonElement) {
                buttonElement.textContent = '生成中...';
                buttonElement.disabled = true;
            }

            const individualButtons = dynamicTablesContainer.querySelectorAll('.export-individual-image-btn');
            individualButtons.forEach(btn => btn.style.visibility = 'hidden');

            try {
                if (!elementToCapture || elementToCapture.innerHTML.trim() === '') {
                    showConfirmDialog("画像化する対象がありません。", null);
                    return;
                }

                const canvas = await html2canvas(elementToCapture, {
                    scale: 2,
                    useCORS: true,
                    logging: false
                });

                const imageDataURL = canvas.toDataURL('image/png');

                const a = document.createElement('a');
                a.href = imageDataURL;
                a.download = `${filenamePrefix}_${new Date().toISOString().slice(0, 10)}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

            } catch (error) {
                console.error("画像エクスポート中にエラーが発生しました:", error);
                showConfirmDialog("画像の生成中にエラーが発生しました。", null);
            } finally {
                individualButtons.forEach(btn => btn.style.visibility = 'visible');

                if (buttonElement) {
                    buttonElement.textContent = '画像をエクスポート';
                    if (buttonElement === exportFullImageBtn) {
                        buttonElement.textContent = '全体画像をエクスポート';
                    }
                    buttonElement.disabled = false;
                }
            }
        }


        /**
         * 現在表示されている全てのテーブルを画像としてエクスポートする処理をします。
         */
        exportFullImageBtn.addEventListener('click', () => {
            exportTableAsImage(dynamicTablesContainer, '人狼ゲーム勝利記録_全体', exportFullImageBtn);
        });

        /**
         * 個別テーブルの画像をエクスポートする処理をします。
         */
        function handleIndividualImageExport(event) {
            const button = event.target;
            const targetId = button.dataset.targetId;
            const filenamePrefix = button.dataset.filenamePrefix;
            const elementToCapture = document.getElementById(targetId);

            if (elementToCapture) {
                exportTableAsImage(elementToCapture, filenamePrefix, button);
            } else {
                showConfirmDialog("指定されたテーブルが見つかりません。", null);
            }
        }


        /**
         * JSONファイルからのデータインポートを処理します。
         * @param {Event} event - ファイル入力からのchangeイベント。
         */
        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedResults = JSON.parse(e.target.result);
                    if (typeof importedResults === 'object' && importedResults !== null) {
                        const newGameResults = {};
                        maps.forEach(map => {
                            newGameResults[map] = {};
                            ['true', 'false'].forEach(foxP => {
                                newGameResults[map][foxP] = newGameResults[map][foxP] || {};
                                ['true', 'false'].forEach(assassinP => {
                                    newGameResults[map][foxP][assassinP] = newGameResults[map][foxP][assassinP] || {};
                                    allFactions.forEach(faction => {
                                        newGameResults[map][foxP][assassinP][faction] = newGameResults[map][foxP][assassinP][faction] || {};
                                        werewolfCounts.forEach(count => {
                                            const value = importedResults[map]?.[foxP]?.[assassinP]?.[faction]?.[count];
                                            const isAllowedInScenario = isScenarioAllowed(foxP === 'true', assassinP === 'true', count);
                                            
                                            const scenarioConfig = Object.values(foxAssassinPresence).find(s => 
                                                String(s.fox) === foxP && String(s.assassin) === assassinP
                                            );
                                            const isFactionExpected = scenarioConfig ? scenarioConfig.displayFactions.includes(faction) : false;

                                            if (isAllowedInScenario && isFactionExpected && typeof value === 'number' && value >= 0) {
                                                newGameResults[map][foxP][assassinP][faction][count] = value;
                                            } else {
                                                newGameResults[map][foxP][assassinP][faction][count] = 0;
                                            }
                                        });
                                    });
                                });
                            });
                        });

                        gameResults = newGameResults;
                        await saveGameResults(); // インポートしたデータをFirestoreに保存
                        showConfirmDialog("データが正常にインポートされました。", null);
                        console.log("データが正常にインポートされました。");
                    } else {
                        showConfirmDialog("無効なJSONファイル形式です。", null);
                        console.error("無効なJSONファイル形式です。");
                    }
                } catch (error) {
                    showConfirmDialog("JSONファイルの解析中にエラーが発生しました。", null);
                    console.error("JSONファイルのパース中にエラーが発生しました:", error);
                } finally {
                    event.target.value = '';
                }
            };
            reader.onerror = () => {
                showConfirmDialog("ファイルの読み込み中にエラーが発生しました。", null);
                console.error("ファイルの読み込み中にエラーが発生しました:", reader.error);
            };
            reader.readAsText(file);
        }

        /**
         * カスタム確認モーダルを表示します。
         * @param {string} message - モーダルに表示するメッセージ。
         * @param {function} onConfirm - ユーザーが確認した場合に実行するコールバック関数。nullの場合、情報メッセージです。
         */
        function showConfirmDialog(message, onConfirm) {
            modalMessage.textContent = message;
            confirmationModal.style.display = 'flex';

            currentConfirmCallback = onConfirm;

            confirmYesBtn.removeEventListener('click', handleConfirmYes);
            confirmNoBtn.removeEventListener('click', handleConfirmNo);

            confirmYesBtn.addEventListener('click', handleConfirmYes);
            confirmNoBtn.addEventListener('click', handleConfirmNo);

            if (!onConfirm) {
                confirmNoBtn.style.display = 'none';
                confirmYesBtn.textContent = 'OK';
                confirmYesBtn.style.backgroundColor = '#4F46E5';
                confirmYesBtn.style.width = '50%';
            } else {
                confirmNoBtn.style.display = 'inline-block';
                confirmYesBtn.textContent = 'はい';
                confirmYesBtn.style.backgroundColor = '#dc2626';
                confirmYesBtn.style.width = 'auto';
            }
        }

        /**
         * 確認モーダルの「はい」ボタンクリックを処理します。
         */
        function handleConfirmYes() {
            if (currentConfirmCallback) {
                currentConfirmCallback();
            }
            confirmationModal.style.display = 'none';
            currentConfirmCallback = null;
        }

        /**
         * 確認モーダルの「いいえ」ボタンクリックを処理します。
         */
        function handleConfirmNo() {
            confirmationModal.style.display = 'none';
            currentConfirmCallback = null;
        }

        /**
         * 確認後に全てのゲームデータをリセットします。
         * Firestoreからもデータをクリアします。
         */
        function resetData() {
            showConfirmDialog("全ての記録をリセットしてもよろしいですか？", async () => {
                if (!userId) {
                    console.warn("ユーザーIDが未設定のため、Firestoreデータをリセットできません。");
                    return;
                }
                try {
                    let targetDocRef;
                    if (currentDataType === 'private') {
                        targetDocRef = privateDocRef;
                    } else if (currentDataType === 'shared') {
                        targetDocRef = sharedDocRef;
                    } else {
                        console.error("無効なデータタイプのためリセットできません。", currentDataType);
                        showConfirmDialog("データのクリア中にエラーが発生しました。無効なデータタイプです。", null);
                        return;
                    }
                    await deleteDoc(targetDocRef);
                    // リアルタイムリスナーがデータをゼロで再初期化し、レンダリングする
                    tableSortStates = {}; // ソート状態もリセット
                    console.log(`Firestoreデータ (${currentDataType}) がリセットされました。`);
                } catch (e) {
                    console.error(`Firestoreデータ (${currentDataType}) のリセット中にエラーが発生しました:`, e);
                    showConfirmDialog("データのクリア中にエラーが発生しました。インターネット接続を確認してください。", null);
                }
            });
        }

        /**
         * スクロール位置に基づいてトップへスクロールボタンの表示を切り替えます。
         */
        function toggleScrollToTopButton() {
            if (window.scrollY > inputSection.offsetTop + inputSection.offsetHeight) {
                scrollToTopBtn.classList.add('visible');
            } else {
                scrollToTopBtn.classList.remove('visible');
            }
        }

        // 認証状態の変更をリッスン
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                userIdDisplay.textContent = userId; // ユーザーIDをUIに表示
                // ドキュメント参照を設定
                privateDocRef = doc(db, FIRESTORE_PRIVATE_RECORDS_COLLECTION_PATH, userId, "records", "werewolfGameResults");
                // 共有データは /artifacts/{appId}/public_shared_records/werewolfGameResults のドキュメントとして扱う
                sharedDocRef = doc(db, FIRESTORE_SHARED_RECORDS_COLLECTION_PATH, "werewolfGameResults"); 
                await loadData(currentDataType); // 認証後にデフォルトのデータをロード
            } else {
                console.log("匿名でサインインします...");
                // Canvas外では直接認証トークンは提供されないため、匿名認証を使用
                await signInAnonymously(auth);
            }
        });

        // イベントリスナー
        addResultBtn.addEventListener('click', handleAddResult);
        exportDataBtn.addEventListener('click', exportData);
        resetDataBtn.addEventListener('click', resetData);
        importDataBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importData);

        showWinsBtn.addEventListener('click', () => {
            displayMode = 'wins';
            renderAllTables();
        });

        showRatesBtn.addEventListener('click', () => {
            displayMode = 'rates';
            renderAllTables();
        });

        // 個人データ・共有データ切り替えボタンのイベントリスナー
        loadPrivateBtn.addEventListener('click', async () => {
            if (currentDataType !== 'private') {
                await loadData('private');
            }
        });

        loadSharedBtn.addEventListener('click', async () => {
            if (currentDataType !== 'shared') {
                await loadData('shared');
            }
        });

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        window.addEventListener('scroll', toggleScrollToTopButton);


        // ページロード時の初期設定
        document.addEventListener('DOMContentLoaded', () => {
            initializeMapSelect();
            // initializeGameResultsはonAuthStateChangedによって呼び出される
            // renderAllTablesはinitializeGameResults内のonSnapshotコールバックによって呼び出される
            toggleScrollToTopButton();
        });
    </script>
</body>
</html>
